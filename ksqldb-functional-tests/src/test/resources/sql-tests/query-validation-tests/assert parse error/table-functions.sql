--@test: table-functions - table function as last select
CREATE STREAM TEST (K STRING KEY, ID BIGINT, MY_ARR ARRAY<BIGINT>) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT K, ID, EXPLODE(MY_ARR) VAL FROM TEST;
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('0', 0, ARRAY[1, 2]);
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('1', 1, ARRAY[3, 4]);
ASSERT VALUES `OUTPUT` (K, ID, VAL) VALUES ('0', 0, 1);
ASSERT VALUES `OUTPUT` (K, ID, VAL) VALUES ('0', 0, 2);
ASSERT VALUES `OUTPUT` (K, ID, VAL) VALUES ('1', 1, 3);
ASSERT VALUES `OUTPUT` (K, ID, VAL) VALUES ('1', 1, 4);

--@test: table-functions - table function as first select
CREATE STREAM TEST (K STRING KEY, ID BIGINT, MY_ARR ARRAY<BIGINT>) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT K, EXPLODE(MY_ARR) AS VAL, ID FROM TEST;
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('0', 0, ARRAY[1, 2]);
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('1', 1, ARRAY[3, 4]);
ASSERT VALUES `OUTPUT` (K, VAL, ID) VALUES ('0', 1, 0);
ASSERT VALUES `OUTPUT` (K, VAL, ID) VALUES ('0', 2, 0);
ASSERT VALUES `OUTPUT` (K, VAL, ID) VALUES ('1', 3, 1);
ASSERT VALUES `OUTPUT` (K, VAL, ID) VALUES ('1', 4, 1);

--@test: table-functions - table function with non selected columns
CREATE STREAM TEST (K STRING KEY, FOO BIGINT, ID BIGINT, MY_ARR ARRAY<BIGINT>, BAR BIGINT) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT K, EXPLODE(MY_ARR) AS VAL, ID FROM TEST;
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('0', 0, ARRAY[1, 2]);
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('1', 1, ARRAY[3, 4]);
ASSERT VALUES `OUTPUT` (K, VAL, ID) VALUES ('0', 1, 0);
ASSERT VALUES `OUTPUT` (K, VAL, ID) VALUES ('0', 2, 0);
ASSERT VALUES `OUTPUT` (K, VAL, ID) VALUES ('1', 3, 1);
ASSERT VALUES `OUTPUT` (K, VAL, ID) VALUES ('1', 4, 1);

--@test: table-functions - table function with no other selected columns
CREATE STREAM TEST (K STRING KEY, FOO BIGINT, ID BIGINT, MY_ARR ARRAY<BIGINT>, BAR BIGINT) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT K, EXPLODE(MY_ARR) AS VAL FROM TEST;
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('0', 0, ARRAY[1, 2]);
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('1', 1, ARRAY[3, 4]);
ASSERT VALUES `OUTPUT` (K, VAL) VALUES ('0', 1);
ASSERT VALUES `OUTPUT` (K, VAL) VALUES ('0', 2);
ASSERT VALUES `OUTPUT` (K, VAL) VALUES ('1', 3);
ASSERT VALUES `OUTPUT` (K, VAL) VALUES ('1', 4);

--@test: table-functions - table function with no alias
CREATE STREAM TEST (K STRING KEY, FOO BIGINT, ID BIGINT, MY_ARR ARRAY<BIGINT>, BAR BIGINT) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT K, EXPLODE(MY_ARR) FROM TEST;
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('0', 0, ARRAY[1, 2]);
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('1', 1, ARRAY[3, 4]);
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0) VALUES ('0', 1);
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0) VALUES ('0', 2);
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0) VALUES ('1', 3);
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0) VALUES ('1', 4);

--@test: table-functions - table function shouldn't be in FROM clause
--@expected.error: io.confluent.ksql.parser.exception.ParseFailedException
--@expected.message: null
CREATE STREAM TEST (K STRING KEY, ID BIGINT, MY_ARR ARRAY<BIGINT>) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT * FROM EXPLODE(MY_ARR);
--@test: table-functions - multiple table functions
CREATE STREAM TEST (ID STRING KEY, MY_ARR1 ARRAY<BIGINT>, MY_ARR2 ARRAY<BIGINT>, BAR BIGINT) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT ID, EXPLODE(MY_ARR1), EXPLODE(MY_ARR2) FROM TEST;
INSERT INTO `TEST` (ID, ID, MY_ARR1, MY_ARR2) VALUES ('0', '0', ARRAY[1, 2], ARRAY[10, 11, 12]);
INSERT INTO `TEST` (ID, ID, MY_ARR1, MY_ARR2) VALUES ('1', '1', ARRAY[3, 4], ARRAY[20]);
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0, KSQL_COL_1) VALUES ('0', 1, 10);
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0, KSQL_COL_1) VALUES ('0', 2, 11);
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0, KSQL_COL_1) VALUES ('0', NULL, 12);
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0, KSQL_COL_1) VALUES ('1', 3, 20);
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0, KSQL_COL_1) VALUES ('1', 4, NULL);

--@test: table-functions - table functions with complex expressions
CREATE STREAM TEST (K STRING KEY, F0 INT, F1 INT, F2 INT, F3 INT) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT K, F0, EXPLODE(ARRAY[ABS(F1 + F2), ABS(F2 + F3), ABS(F3 + F1)]) FROM TEST;
INSERT INTO `TEST` (K, F0, F1, F2, F3) VALUES ('0', 1, 10, 11, 12);
ASSERT VALUES `OUTPUT` (K, F0, KSQL_COL_0) VALUES ('0', 1, 21);
ASSERT VALUES `OUTPUT` (K, F0, KSQL_COL_0) VALUES ('0', 1, 23);
ASSERT VALUES `OUTPUT` (K, F0, KSQL_COL_0) VALUES ('0', 1, 22);

--@test: table-functions - test_udtf - simple params
CREATE STREAM TEST (K STRING KEY, F0 INT, F1 BIGINT, F2 DOUBLE, F3 BOOLEAN, F4 STRING, F5 DECIMAL(20, 10), F6 STRUCT<A VARCHAR>) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT K, TEST_UDTF(F0, F1, F2, F3, F4, F5, F6) FROM TEST;
INSERT INTO `TEST` (K, F0, F1, F2, F3, F4, F5, F6) VALUES ('0', 1, 2, 3.1, true, 'foo', 123.4560000000, STRUCT(A:='bar'));
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0) VALUES ('0', '1');
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0) VALUES ('0', '2');
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0) VALUES ('0', '3.1');
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0) VALUES ('0', 'true');
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0) VALUES ('0', 'foo');
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0) VALUES ('0', '123.4560000000');
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0) VALUES ('0', 'Struct{A=bar}');

--@test: table-functions - test_udtf - key column
CREATE STREAM TEST (ID INT KEY, NAME STRING) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT ID, TEST_UDTF(ID) FROM TEST;
INSERT INTO `TEST` (ID, NAME) VALUES (10, 'bob');
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES (10, 10);
ASSERT stream OUTPUT (ID INT KEY, KSQL_COL_0 INT) WITH (KAFKA_TOPIC='OUTPUT');

--@test: table-functions - test_udtf - array params
CREATE STREAM TEST (ID STRING KEY, F0 ARRAY<INT>, F1 ARRAY<BIGINT>, F2 ARRAY<DOUBLE>, F3 ARRAY<BOOLEAN>, F4 ARRAY<STRING>, F5 ARRAY<DECIMAL(20, 10)>, F6 ARRAY<STRUCT<A VARCHAR>>) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT ID, TEST_UDTF(F0, F1, F2, F3, F4, F5, F6) FROM TEST;
INSERT INTO `TEST` (ID, F0, F1, F2, F3, F4, F5, F6) VALUES ('0', ARRAY[1], ARRAY[2], ARRAY[3.1], ARRAY[true], ARRAY['foo'], ARRAY[123.456], ARRAY[STRUCT(A:='bar')]);
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', '1');
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', '2');
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', '3.1');
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', 'true');
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', 'foo');
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', '123.4560000000');
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', 'Struct{A=bar}');

--@test: table-functions - test_udtf - map params
CREATE STREAM TEST (ID STRING KEY, F0 MAP<STRING, INT>, F1 MAP<STRING, BIGINT>, F2 MAP<STRING, DOUBLE>, F3 MAP<STRING, BOOLEAN>, F4 MAP<STRING, STRING>, F5 MAP<STRING, DECIMAL(20, 10)>, F6 MAP<STRING, STRUCT<A VARCHAR>>) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT ID, TEST_UDTF(F0, F1, F2, F3, F4, F5, F6) FROM TEST;
INSERT INTO `TEST` (ID, F0, F1, F2, F3, F4, F5, F6) VALUES ('0', MAP('k':=1), MAP('k':=2), MAP('k':=3.1), MAP('k':=true), MAP('k':='foo'), MAP('k':=123.456), MAP('k':=STRUCT(A:='bar')));
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', '1');
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', '2');
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', '3.1');
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', 'true');
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', 'foo');
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', '123.4560000000');
ASSERT VALUES `OUTPUT` (ID, KSQL_COL_0) VALUES ('0', 'Struct{A=bar}');

--@test: table-functions - test_udtf - return vals
CREATE STREAM TEST (K STRING KEY, F0 INT, F1 BIGINT, F2 DOUBLE, F3 BOOLEAN, F4 STRING, F5 DECIMAL(20, 10), F6 STRUCT<A VARCHAR>) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT K, TEST_UDTF(F0), TEST_UDTF(F1), TEST_UDTF(F2), TEST_UDTF(F3), TEST_UDTF(F4), TEST_UDTF(F5), TEST_UDTF(F6) FROM TEST;
INSERT INTO `TEST` (K, F0, F1, F2, F3, F4, F5, F6) VALUES ('0', 1, 2, 3.1, true, 'foo', 123.456, STRUCT(A:='bar'));
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0, KSQL_COL_1, KSQL_COL_2, KSQL_COL_3, KSQL_COL_4, KSQL_COL_5, KSQL_COL_6) VALUES ('0', 1, 2, 3.1, true, 'foo', 123.4560000000, STRUCT(A:='bar'));
ASSERT stream OUTPUT (K STRING KEY, KSQL_COL_0 INT, KSQL_COL_1 BIGINT, KSQL_COL_2 DOUBLE, KSQL_COL_3 BOOLEAN, KSQL_COL_4 STRING, KSQL_COL_5 DECIMAL(30, 10), KSQL_COL_6 STRUCT<A VARCHAR>) WITH (KAFKA_TOPIC='OUTPUT');

--@test: table-functions - table function with where clause
CREATE STREAM TEST (K STRING KEY, F0 INT, F1 ARRAY<INT>) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT K, F0, EXPLODE(F1) VAL FROM TEST WHERE F0 <> 1;
INSERT INTO `TEST` (K, F0, F1) VALUES ('0', 0, ARRAY[1, 2, 3]);
INSERT INTO `TEST` (K, F0, F1) VALUES ('0', 1, ARRAY[4, 5, 6]);
INSERT INTO `TEST` (K, F0, F1) VALUES ('0', 2, ARRAY[7, 8, 9]);
ASSERT VALUES `OUTPUT` (K, F0, VAL) VALUES ('0', 0, 1);
ASSERT VALUES `OUTPUT` (K, F0, VAL) VALUES ('0', 0, 2);
ASSERT VALUES `OUTPUT` (K, F0, VAL) VALUES ('0', 0, 3);
ASSERT VALUES `OUTPUT` (K, F0, VAL) VALUES ('0', 2, 7);
ASSERT VALUES `OUTPUT` (K, F0, VAL) VALUES ('0', 2, 8);
ASSERT VALUES `OUTPUT` (K, F0, VAL) VALUES ('0', 2, 9);

--@test: table-functions - table functions don't support table sources
--@expected.error: io.confluent.ksql.util.KsqlException
--@expected.message: Table source is not supported with table functions
CREATE TABLE TEST (K STRING PRIMARY KEY, ID BIGINT, MY_ARR ARRAY<BIGINT>) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE TABLE OUTPUT AS SELECT K, ID, EXPLODE(MY_ARR) VAL FROM TEST;
--@test: table-functions - with select *
CREATE STREAM TEST (ID STRING KEY, MY_ARR ARRAY<BIGINT>) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT *, EXPLODE(MY_ARR) VAL FROM TEST;
INSERT INTO `TEST` (ID, MY_ARR) VALUES ('0', ARRAY[1, 2]);
INSERT INTO `TEST` (ID, MY_ARR) VALUES ('1', ARRAY[3, 4]);
ASSERT VALUES `OUTPUT` (ID, MY_ARR, VAL) VALUES ('0', ARRAY[1, 2], 1);
ASSERT VALUES `OUTPUT` (ID, MY_ARR, VAL) VALUES ('0', ARRAY[1, 2], 2);
ASSERT VALUES `OUTPUT` (ID, MY_ARR, VAL) VALUES ('1', ARRAY[3, 4], 3);
ASSERT VALUES `OUTPUT` (ID, MY_ARR, VAL) VALUES ('1', ARRAY[3, 4], 4);

--@test: table-functions - with duplicate columns
CREATE STREAM TEST (K STRING KEY, ID BIGINT, MY_ARR ARRAY<BIGINT>) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT K, ID, EXPLODE(MY_ARR) VAL, ID AS ID2 FROM TEST;
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('0', 0, ARRAY[1, 2]);
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('1', 1, ARRAY[3, 4]);
ASSERT VALUES `OUTPUT` (K, ID, VAL, ID2) VALUES ('0', 0, 1, 0);
ASSERT VALUES `OUTPUT` (K, ID, VAL, ID2) VALUES ('0', 0, 2, 0);
ASSERT VALUES `OUTPUT` (K, ID, VAL, ID2) VALUES ('1', 1, 3, 1);
ASSERT VALUES `OUTPUT` (K, ID, VAL, ID2) VALUES ('1', 1, 4, 1);

--@test: table-functions - with duplicate udtfs
CREATE STREAM TEST (K STRING KEY, ID BIGINT, MY_ARR ARRAY<BIGINT>) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT K, EXPLODE(MY_ARR), EXPLODE(MY_ARR) FROM TEST;
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('0', 0, ARRAY[1, 2]);
INSERT INTO `TEST` (K, ID, MY_ARR) VALUES ('1', 1, ARRAY[3, 4]);
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0, KSQL_COL_1) VALUES ('0', 1, 1);
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0, KSQL_COL_1) VALUES ('0', 2, 2);
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0, KSQL_COL_1) VALUES ('1', 3, 3);
ASSERT VALUES `OUTPUT` (K, KSQL_COL_0, KSQL_COL_1) VALUES ('1', 4, 4);

--@test: table-functions - should handle UDTFs that throw
CREATE STREAM TEST (K STRING KEY, shouldThrow BOOLEAN) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT K, shouldThrow, throwing_udtf(shouldThrow) FROM TEST;
INSERT INTO `TEST` (K, shouldThrow) VALUES ('a', false);
INSERT INTO `TEST` (K, shouldThrow) VALUES ('b', true);
INSERT INTO `TEST` (K, shouldThrow) VALUES ('c', false);
ASSERT VALUES `OUTPUT` (K, SHOULDTHROW, KSQL_COL_0) VALUES ('a', false, false);
ASSERT VALUES `OUTPUT` (K, SHOULDTHROW, KSQL_COL_0) VALUES ('c', false, false);

--@test: table-functions - should handle UDTF parameter evaluation that throws
CREATE STREAM TEST (K STRING KEY, shouldThrow BOOLEAN) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT K, shouldThrow, test_udtf(bad_udf(shouldThrow)) FROM TEST;
INSERT INTO `TEST` (K, shouldThrow) VALUES ('a', false);
INSERT INTO `TEST` (K, shouldThrow) VALUES ('b', true);
INSERT INTO `TEST` (K, shouldThrow) VALUES ('c', false);
ASSERT VALUES `OUTPUT` (K, SHOULDTHROW, KSQL_COL_0) VALUES ('a', false, 0);
ASSERT VALUES `OUTPUT` (K, SHOULDTHROW, KSQL_COL_0) VALUES ('c', false, 0);

--@test: table-functions - stream without key
CREATE STREAM TEST (ID BIGINT, MY_ARR ARRAY<BIGINT>) WITH (kafka_topic='test_topic', value_format='JSON');
CREATE STREAM OUTPUT AS SELECT ID, EXPLODE(MY_ARR) VAL, ID AS ID2 FROM TEST;
INSERT INTO `TEST` (ID, MY_ARR) VALUES (0, ARRAY[1, 2]);
INSERT INTO `TEST` (ID, MY_ARR) VALUES (1, ARRAY[3, 4]);
ASSERT VALUES `OUTPUT` (ID, VAL, ID2) VALUES (0, 1, 0);
ASSERT VALUES `OUTPUT` (ID, VAL, ID2) VALUES (0, 2, 0);
ASSERT VALUES `OUTPUT` (ID, VAL, ID2) VALUES (1, 3, 1);
ASSERT VALUES `OUTPUT` (ID, VAL, ID2) VALUES (1, 4, 1);

